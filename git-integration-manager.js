#!/usr/bin/env node

/**
 * Git Integration Manager for DevAssist
 * Provides intelligent git operations with:
 * - Automatic commits on session end
 * - Smart commit message generation
 * - Optional push with confirmation
 * - Session-based change tracking
 */

const fs = require('fs');
const path = require('path');
const { exec, execSync } = require('child_process');
const readline = require('readline');

class GitIntegrationManager {
  constructor(projectPath = process.cwd()) {
    this.projectPath = projectPath;
    this.projectName = path.basename(projectPath);
    this.sessionsPath = path.join(projectPath, '.sessions');
    this.summaryFile = path.join(projectPath, 'PROJECT_SESSIONS.md');
  }

  /**
   * Generate intelligent commit message based on changes
   */
  async generateCommitMessage(sessionData) {
    console.log('\n🤖 Generating intelligent commit message...');
    
    try {
      // Get git status and diff stats
      const status = await this.execCommand('git status --short');
      const diffStat = await this.execCommand('git diff --stat');
      
      // Analyze changes
      const changes = this.analyzeChanges(status, diffStat);
      
      // Build commit message
      const sessionId = sessionData?.id || new Date().toISOString();
      const duration = sessionData ? this.calculateDuration(sessionData) : 'unknown';
      
      // Primary message
      let message = `✨ Session ${sessionId}: ${this.projectName} development\n\n`;
      
      // Add change summary
      message += '## Changes Made\n';
      
      if (changes.added.length > 0) {
        message += `- Added: ${changes.added.join(', ')}\n`;
      }
      
      if (changes.modified.length > 0) {
        message += `- Modified: ${changes.modified.join(', ')}\n`;
      }
      
      if (changes.deleted.length > 0) {
        message += `- Deleted: ${changes.deleted.join(', ')}\n`;
      }
      
      // Add statistics
      message += `\n## Session Stats\n`;
      message += `- Duration: ${duration}\n`;
      message += `- Files changed: ${changes.totalFiles}\n`;
      message += `- Insertions: ${changes.insertions}\n`;
      message += `- Deletions: ${changes.deletions}\n`;
      
      // Add DevAssist signature
      message += `\n🤖 Generated by DevAssist Session Manager\n`;
      message += `Project: ${this.projectName}`;
      
      return message;
    } catch (error) {
      console.log('⚠️  Using fallback commit message');
      return `Session update for ${this.projectName} - ${new Date().toISOString()}`;
    }
  }

  /**
   * Analyze git changes
   */
  analyzeChanges(status, diffStat) {
    const changes = {
      added: [],
      modified: [],
      deleted: [],
      totalFiles: 0,
      insertions: 0,
      deletions: 0
    };
    
    // Parse status output
    const lines = status.split('\n').filter(l => l.trim());
    
    for (const line of lines) {
      const [type, ...pathParts] = line.trim().split(/\s+/);
      const filepath = pathParts.join(' ');
      
      if (!filepath) continue;
      
      // Get just the filename for the summary
      const filename = path.basename(filepath);
      
      if (type === 'A' || type === '??') {
        changes.added.push(filename);
      } else if (type === 'M' || type === 'AM') {
        changes.modified.push(filename);
      } else if (type === 'D') {
        changes.deleted.push(filename);
      }
      
      changes.totalFiles++;
    }
    
    // Parse diff stats for insertions/deletions
    const statsMatch = diffStat.match(/(\d+) insertions?\(\+\)/);
    const delsMatch = diffStat.match(/(\d+) deletions?\(-\)/);
    
    if (statsMatch) {
      changes.insertions = parseInt(statsMatch[1]);
    }
    
    if (delsMatch) {
      changes.deletions = parseInt(delsMatch[1]);
    }
    
    // Limit arrays to prevent huge commit messages
    changes.added = changes.added.slice(0, 5);
    changes.modified = changes.modified.slice(0, 5);
    changes.deleted = changes.deleted.slice(0, 5);
    
    return changes;
  }

  /**
   * Perform git commit with intelligent message
   */
  async commitChanges(sessionData) {
    console.log('\n📦 Performing Git Operations...');
    
    try {
      // Check if there are changes to commit
      const status = await this.execCommand('git status --short');
      
      if (!status.trim()) {
        console.log('  ℹ️  No changes to commit');
        return false;
      }
      
      // Stage all changes
      console.log('  📝 Staging changes...');
      await this.execCommand('git add -A');
      
      // Generate commit message
      const message = await this.generateCommitMessage(sessionData);
      
      // Create commit
      console.log('  💾 Creating commit...');
      
      // Write message to temp file to handle multi-line commits
      const tempFile = path.join(this.projectPath, '.git', 'COMMIT_MSG_TEMP');
      fs.writeFileSync(tempFile, message);
      
      try {
        await this.execCommand(`git commit -F "${tempFile}"`);
        console.log('  ✅ Changes committed successfully!');
        
        // Clean up temp file
        if (fs.existsSync(tempFile)) {
          fs.unlinkSync(tempFile);
        }
        
        return true;
      } catch (commitError) {
        // Clean up temp file even on error
        if (fs.existsSync(tempFile)) {
          fs.unlinkSync(tempFile);
        }
        throw commitError;
      }
    } catch (error) {
      console.log('  ⚠️  Git commit failed:', error.message);
      return false;
    }
  }

  /**
   * Optional git push with confirmation
   */
  async pushChanges(skipConfirmation = false) {
    console.log('\n🚀 Git Push Options');
    
    try {
      // Check if we have a remote
      const remotes = await this.execCommand('git remote');
      
      if (!remotes.trim()) {
        console.log('  ℹ️  No git remotes configured');
        return false;
      }
      
      // Get current branch
      const branch = await this.execCommand('git branch --show-current');
      const currentBranch = branch.trim() || 'main';
      
      // Check for unpushed commits
      const unpushed = await this.execCommand(`git log origin/${currentBranch}..HEAD --oneline 2>/dev/null || echo ""`);
      
      if (!unpushed.trim()) {
        console.log('  ℹ️  No commits to push');
        return false;
      }
      
      console.log(`  📊 Unpushed commits on ${currentBranch}:`);
      console.log(unpushed.split('\n').map(l => '     ' + l).join('\n'));
      
      if (!skipConfirmation) {
        const shouldPush = await this.promptUser('\n  Push changes to remote? (y/n): ');
        
        if (shouldPush.toLowerCase() !== 'y') {
          console.log('  ⏭️  Push skipped');
          return false;
        }
      }
      
      // Perform push
      console.log(`  🔄 Pushing to origin/${currentBranch}...`);
      await this.execCommand(`git push origin ${currentBranch}`);
      console.log('  ✅ Changes pushed successfully!');
      
      return true;
    } catch (error) {
      console.log('  ⚠️  Git push failed:', error.message);
      return false;
    }
  }

  /**
   * Create session branch (optional workflow)
   */
  async createSessionBranch(sessionId) {
    const branchName = `session/${sessionId.replace(/[:.]/g, '-')}`;
    
    try {
      await this.execCommand(`git checkout -b ${branchName}`);
      console.log(`  🌿 Created session branch: ${branchName}`);
      return branchName;
    } catch (error) {
      console.log('  ℹ️  Continuing on current branch');
      return null;
    }
  }

  /**
   * Merge session branch back to main
   */
  async mergeSessionBranch(branchName, targetBranch = 'main') {
    try {
      // Switch to target branch
      await this.execCommand(`git checkout ${targetBranch}`);
      
      // Merge session branch
      await this.execCommand(`git merge ${branchName} --no-ff -m "Merge session branch ${branchName}"`);
      
      // Delete session branch
      await this.execCommand(`git branch -d ${branchName}`);
      
      console.log(`  ✅ Merged ${branchName} into ${targetBranch}`);
      return true;
    } catch (error) {
      console.log(`  ⚠️  Merge failed: ${error.message}`);
      return false;
    }
  }

  /**
   * Auto-stash uncommitted changes before operations
   */
  async stashIfNeeded() {
    try {
      const status = await this.execCommand('git status --short');
      
      if (status.trim()) {
        const stashName = `DevAssist-autosave-${Date.now()}`;
        await this.execCommand(`git stash push -m "${stashName}"`);
        console.log(`  📥 Changes stashed: ${stashName}`);
        return stashName;
      }
    } catch (error) {
      console.log('  ⚠️  Could not stash changes');
    }
    
    return null;
  }

  /**
   * Calculate session duration
   */
  calculateDuration(sessionData) {
    if (!sessionData.started) return 'unknown';
    
    const start = new Date(sessionData.started);
    const end = sessionData.ended ? new Date(sessionData.ended) : new Date();
    const duration = end - start;
    
    const hours = Math.floor(duration / (1000 * 60 * 60));
    const minutes = Math.floor((duration % (1000 * 60 * 60)) / (1000 * 60));
    
    if (hours > 0) {
      return `${hours}h ${minutes}m`;
    }
    return `${minutes}m`;
  }

  /**
   * Execute command with promise
   */
  execCommand(command) {
    return new Promise((resolve, reject) => {
      exec(command, { cwd: this.projectPath }, (error, stdout, stderr) => {
        if (error && !command.includes('2>/dev/null')) {
          reject(error);
        } else {
          resolve(stdout);
        }
      });
    });
  }

  /**
   * Prompt user for input
   */
  promptUser(question) {
    return new Promise((resolve) => {
      const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
      });
      
      rl.question(question, (answer) => {
        rl.close();
        resolve(answer);
      });
    });
  }

  /**
   * Complete git workflow for session end
   */
  async performCompleteGitWorkflow(sessionData) {
    console.log('\n=== Git Integration Workflow ===');
    
    // 1. Commit changes
    const committed = await this.commitChanges(sessionData);
    
    if (committed) {
      // 2. Optional push
      await this.pushChanges();
    }
    
    // 3. Log summary
    console.log('\n📊 Git Summary:');
    const log = await this.execCommand('git log --oneline -5');
    console.log(log.split('\n').map(l => '  ' + l).join('\n'));
    
    return committed;
  }
}

// Export for use
module.exports = GitIntegrationManager;

// CLI interface
if (require.main === module) {
  const command = process.argv[2];
  const manager = new GitIntegrationManager();
  
  switch (command) {
    case 'commit':
      manager.commitChanges().then(() => {
        console.log('Done!');
      });
      break;
      
    case 'push':
      manager.pushChanges().then(() => {
        console.log('Done!');
      });
      break;
      
    case 'workflow':
      manager.performCompleteGitWorkflow().then(() => {
        console.log('Done!');
      });
      break;
      
    default:
      console.log('Usage: git-integration [commit|push|workflow]');
  }
}